# Effective C++开发规范条款

## 条款16 成对使用new和delete

### new创建，delete删除

### new[]创建，delete[]删除

## 条款30 了解inline的里里外外

### inline函数，对函数的每一个调用都用函数本体代替，调用不承受额外的开销，编译器对齐执行语境相关最优化。

### 增加目标码大小，额外的换页行为，降低缓存命中率，效率损失。

### 对虚函数进行inline无意义，虚函数是运行时确定，inline是在编译期替换

### 编译器一般不对“通过函数指针进行调用”提供inline，是否inline取决于调用的方式

## 条款34 区分接口继承和实现继承

### public继承由函数结构继承+函数实现继承组成

### 纯虚函数两个特性：它们必须被任何继承了它们的具象class重新声明；在抽象class中通常没有定义

### 声明一个纯虚函数的目的是为了让派生类继承函数的接口。只提供接口，派生类根据自身去需要去实现具体定义

### 声明非纯虚函数的目的是让派生类继承函数的接口和缺省实现。必须支持一个虚函数，如果不想重新写一个（override），可以使用基类提供的缺省版本

### 声明非虚函数的目的是令派生类继承函数接口和一份强制性实现。任何派生类都不应该尝试修改此函数，non-virtual函数代表不变性>特异性，不应该在派生类被重新定义

## 条款35 考虑virtual函数以外的其他选择

### non-virtual interface：以public non-virtual成员函数包裹较低访问性（private/protected）的虚函数。

### virtual函数替换成”函数指针成员变量“

### tr1::function成员变量替换virtual

## 条款36 绝不重新定义继承而来的非虚函数

### public继承说明，每个派生类对象都是基类对象，非虚函数（静态绑定）一定会继承基类的接口和实现

### 重新定义则设计出现矛盾。派生类重新定义使得出现特化，这样就不一定适用于基类，那么就不应该public

## 条款37 绝不重新定义继承而来的缺省参数值

### 因为缺省参数值是静态绑定，虚函数是动态绑定

### 静态类型是程序中被声明时采用的类型，动态类型是目前所指对象的类型

## 条款39 明智而审慎的使用private继承

### 如果派生类需要访问基类保护的成员，或需要重新定义继承来的虚函数，采用private继承

## 条款40 明智而审慎的使用多重继承

### 多继承中实现派生类中只有一份数据，虚继承

### 虚继承会增加大小、速度、初始化等成本

### 最好不要使用虚继承或者虚基类中放置数据

## 条款44 将与参数无关的代码抽离templates

### template生成多个classes和多个函数，所以任何template代码都不应该与某个造成膨胀的template参数产生相依关系

### 因非类型模板参数（non-type template parameters）而造成代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数

### 因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有相同二进制表述的具象类型共享实现码

## 条款45 运用成员函数模板接受所有的兼容类型

### 如果你声明member template用于“泛化copy构造”或者“泛化assignment操作”，你还需要声明正常的copy构造函数和copy assignment操作符

## 条款46 需要类型转换时请为模板定义非成员函数

### 当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数

## 条款47 请使用traits classes表现类型信息

### traits classes使得”类型相关信息“在编译期可用

### 它们以template和”template特化“完成实现，整合重载技术后，traits classes有可能在编译期对类型执行if else 测试

## 条款48 认识template元编程

### template meta programming（模板元编程）可将工作由运行期移往编译期，因而得以实现早起错误侦测和更高的执行效率

### TMP可被用来生成”基于政策选择组会“的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码

